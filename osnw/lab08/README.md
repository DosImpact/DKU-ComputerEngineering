## 목표

과제 시나리오

1. 멀티스레드 서버 아키텍처를 만든다.  
   1.1 클라이언트의 accept는 메인 스레드가 담당하고  
   1.2 이후의 네트워크 IO는 워커 스레드가 담당한다.

2. 서버워커스레드는 프로듀서와 컨슈머로 분리된다. ( 워커스레드 2개 생성 )  
   2.1 프로듀서 스레드는 클라이언트로부터 정수,문자열을 받는다.
   2.2 받은 정수는 1씩 증가를 시키고, 문자열은 rotate를 하며 공유메모리 공간에 넣는다.  
   2.3 컨슈머 스레드는 공유메모리공간의 데이터를 받아온다.
   2.4 받은 데이터를 클라이언트로 전송한다.

- 스레드간의 크리티컬 섹션에는 뮤텍스와 signal&wait(동기화)를 활용해서 공유자원에 대한 보호를 한다.

3. 클라이언트는 받은 데이터를 출력하며, 무한루프를 돈다.

## 코드 스니펫

1. 구조체 네트워크 io
2. 스레드간 공유 변수 구조체 만들기
3. 스레드간 뮤텍스 보장
4. 스레드간 동기화 (시그널) 보장  
   4.1 프로듀서의 생성 시작 기다리기  
   4.2 프로듀서의 CS접근 종료 기다리기

```c
	pthread_mutex_lock(&t_lock[lock_id]); // --- CS 섹션 START
	pthread_cond_signal(&t_lock[lock_id]);
  pthread_cond_wait(&t_cond[lock_id], &t_lock[lock_id]);
	pthread_mutex_unlock(&t_lock[lock_id]); // --- CS 섹션 END
```

### 핵심 키워드

멀티스레드, 소켓 프로그래밍, producer-consumer 패턴  
뮤텍스(세마포어)

## dist 코드 컴파일

gcc ./echo_server_thread.c -o echo_server_thread -lpthread
gcc ./echo_client.c -o echo_client

## 예제 코드(src폴더) 설명

### 스레드 라이브러리 포함하는 옵션을 주어 컴파일 하기

gcc 컴파일시 lpthread 라는 라이브러리를 링크할때 써라

> gcc -o thread1 thread1.c -lpthread

프로세스의 상태를 볼 때 L 옵션을 주어 스레드까지 보자.

> ps -eLf

### thread1.c

```
/* 스레드 예제1) 생성  */
```

### thread2.c

```

/* 스레드 예제2) 생성 (+인자값)  */
// 문제점 : main 스레드의 stack 변수를 참조하므로, 스레드간 의존성이 높아졌다.
```

### thread3.c

```
/* 스레드 예제3) 생성 (+인자값)  */
// 문제점 : main 스레드의 stack 변수를 참조하므로, 스레드간 의존성이 높아졌다.
// thread2예제와 같은 로직이지만 sub함수로 분리를 하였더니, 변수참조에 문제가 발생
// (워커스레드에서 사용중인 변수를 메인스레드에서 sub함수 종료 후 변수를 제거 한 상황  )
```

### thread4.c

```
/* 스레드 예제4) 생성 (+인자값)  */
// 워커스레드에서 사용중인 동적할당 변수를 메인스레드에서 free(해체) 한 상황
// *스레드간 heap영역을 공유하므로 서로간의 합이 안맞은 상황이다.
```

### count_thread.c

```
/* 스레드 예제5) 스레드 카운터

  메인 스레드의 count 변수를 , 워커 스레드들이 참조하여 +1 씩 올려주고 있다.
  이 예제에서는 race condition문제가 발생하지 않는다.
*/
```

### count_thread_race.c

```
/* 스레드 예제6) 스레드 카운터  (+레이스 컨디션)

  메인 스레드의 count 변수를 , 워커 스레드들이 참조하여 +1 씩 올려주고 있다.
  이 예제에서는 race condition문제가 발생한다.
  2개의 워커 스레드가 count변수에 동시에 접근하게 된다.
  이를 다음 예제에서는 한 스레드만 CS에 접근하도록 mutex를 걸자
	...
	281473203630560 7
	281473195237856 7
	Main Thread : 8
	...
*/
```

### count_thread_mutex.c

```
/* 스레드 예제 7) 스레드 카운터  (+레이스 컨디션,+ mutex lock)

  메인 스레드의 count 변수를 , 워커 스레드들이 참조하여 +1 씩 올려주고 있다.
  mutex lock 을 통해 한번에 한 스레드만 count 변수에 접근이 가능하다.
*/
```

### calc_multi.c

```
/* 스레드 예제 8) 스레드간 동기화 ( signal & wait )

*/
```

### echo_server_thread.c

```
/* 스레드 예제 9) 스레드 에코 서버
	- 서버 접속시 accpet은 메인 스레드가 ,
	- 이후 read/write는 서브 스레드가 담당
*/
```
